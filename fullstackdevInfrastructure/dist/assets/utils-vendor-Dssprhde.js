function e(e,t){let n;try{n=e()}catch{return}return{getItem:e=>{let r=e=>e===null?null:JSON.parse(e,t?.reviver),i=n.getItem(e)??null;return i instanceof Promise?i.then(r):r(i)},setItem:(e,r)=>n.setItem(e,JSON.stringify(r,t?.replacer)),removeItem:e=>n.removeItem(e)}}var t=e=>n=>{try{let r=e(n);return r instanceof Promise?r:{then(e){return t(e)(r)},catch(e){return this}}}catch(e){return{then(e){return this},catch(n){return t(n)(e)}}}},n=(n,r)=>(i,a,o)=>{let s={storage:e(()=>localStorage),partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...r},c=!1,l=new Set,u=new Set,d=s.storage;if(!d)return n((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),i(...e)},a,o);let f=()=>{let e=s.partialize({...a()});return d.setItem(s.name,{state:e,version:s.version})},p=o.setState;o.setState=(e,t)=>(p(e,t),f());let m=n((...e)=>(i(...e),f()),a,o);o.getInitialState=()=>m;let h,g=()=>{if(!d)return;c=!1,l.forEach(e=>e(a()??m));let e=s.onRehydrateStorage?.call(s,a()??m)||void 0;return t(d.getItem.bind(d))(s.name).then(e=>{if(e)if(typeof e.version==`number`&&e.version!==s.version){if(s.migrate){let t=s.migrate(e.state,e.version);return t instanceof Promise?t.then(e=>[!0,e]):[!0,t]}console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`)}else return[!1,e.state];return[!1,void 0]}).then(e=>{let[t,n]=e;if(h=s.merge(n,a()??m),i(h,!0),t)return f()}).then(()=>{e?.(h,void 0),h=a(),c=!0,u.forEach(e=>e(h))}).catch(t=>{e?.(void 0,t)})};return o.persist={setOptions:e=>{s={...s,...e},e.storage&&(d=e.storage)},clearStorage:()=>{d?.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>g(),hasHydrated:()=>c,onHydrate:e=>(l.add(e),()=>{l.delete(e)}),onFinishHydration:e=>(u.add(e),()=>{u.delete(e)})},s.skipHydration||g(),h||m};export{n,e as t};